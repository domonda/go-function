package gen

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"

	"golang.org/x/tools/imports"
)

// PackageFunctions generates wrapper implementations for functions in a package.
// This function is used for the older generation approach where all wrappers
// are written to a single generated file.
//
// Parameters:
//   - pkgDir: Directory containing the package to process
//   - genFilename: Name of the file to generate (e.g., "generated.go")
//   - namePrefix: Prefix to add to generated type names (e.g., "Func")
//   - printOnly: If true, print to stdout instead of writing file
//   - jsonTypeReplacements: Map of interface types to concrete types for JSON unmarshalling
//   - onlyFuncs: Optional list of specific functions to wrap; if empty, wraps all exported functions
//
// Returns:
//   - error if parsing, generation, or file writing fails
//
// The function:
//  1. Parses the package and extracts function declarations
//  2. Gathers all required imports from function signatures
//  3. Generates wrapper implementations for each function
//  4. Formats the code with proper imports
//  5. Writes to genFilename or prints to stdout if printOnly is true
//
// Example generated file structure:
//
//	// This file has been AUTOGENERATED!
//
//	package mypackage
//
//	import (
//	    "context"
//	    "reflect"
//	    function "github.com/domonda/go-function"
//	)
//
//	type FuncMyFunction struct{}
//	// ... wrapper methods ...
func PackageFunctions(pkgDir, genFilename, namePrefix string, printOnly bool, jsonTypeReplacements map[string]string, onlyFuncs ...string) error {
	pkg, funcs, err := parsePackage(pkgDir, genFilename, onlyFuncs...)
	if err != nil {
		return err
	}

	importLines := map[string]struct{}{
		`"reflect"`: {},
		`"context"`: {},
		`function "github.com/domonda/go-function"`: {},
	}
	for _, fun := range funcs {
		err = gatherFieldListImports(fun.File, fun.Decl.Type.Params, importLines)
		if err != nil {
			return err
		}
		err = gatherFieldListImports(fun.File, fun.Decl.Type.Results, importLines)
		if err != nil {
			return err
		}
	}
	var sortedImportLines []string
	for l := range importLines {
		sortedImportLines = append(sortedImportLines, l)
	}
	sort.Strings(sortedImportLines)

	b := bytes.NewBuffer(nil)

	fmt.Fprintf(b, "// This file has been AUTOGENERATED!\n\n")
	fmt.Fprintf(b, "package %s\n\n", pkg.Name)
	if len(sortedImportLines) > 0 {
		fmt.Fprintf(b, "import (\n")
		for _, importLine := range sortedImportLines {
			fmt.Fprintf(b, "\t%s\n", importLine)
		}
		fmt.Fprintf(b, ")\n\n")
	}

	for funName, fun := range funcs {
		err = ImplWrapper.WriteFunctionWrapper(b, fun.File, fun.Decl, namePrefix+funName, "", importLines, jsonTypeReplacements)
		if err != nil {
			return err
		}
	}

	genFileData := b.Bytes()
	genFilePath := filepath.Join(pkgDir, genFilename)

	imports.LocalPrefix = "github.com/domonda/"
	genFileData, err = imports.Process(genFilePath, genFileData, &imports.Options{Comments: true, FormatOnly: true})
	if err != nil {
		return err
	}

	if printOnly {
		fmt.Println(genFileData)
	} else {
		fmt.Println("Writing file", genFilePath)
		err = os.WriteFile(genFilePath, genFileData, 0644)
		if err != nil {
			return err
		}
	}
	// err = exec.Command("gofmt", "-s", "-w", genFile).Run()
	// if err != nil {
	// 	return err
	// }

	return nil
}
